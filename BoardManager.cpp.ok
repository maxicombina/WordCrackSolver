/* 
 * File:   BoardManager.cpp
 * Author: maxlo
 * 
 * Created on May 28, 2014, 8:21 PM
 */

#include <vector>
#include <iostream>
#include <sstream>

#include "BoardManager.h"
#include "debug.h"

static std::string ngbsToString(std::vector<Node*> v)
{
    //std::cerr << "ngbs: " << v.size() << std::endl;
    std::stringstream s("");
    s << "[";
    for (int i = 0; i < v.size()-1; i++) {
        s << v[i]->letter();
        s << ", ";
    }
    s << v[v.size()-1]->letter();
    s << "]";
    return s.str();
}

static std::string pathsToString(std::vector<std::vector<Node*> > v)
{
    if (v.size() == 0) {
        return std::string("<<>>");
    }
    std::stringstream s("");
    s << "<<";
    for (int i = 0; i < v.size()-1; i++) {
        s << ngbsToString(v[i]);
        s << ", ";
    }
    if (v.size() > 0) {
        s << ngbsToString(v[v.size()-1]);
    }
    s << ">>";
    return s.str();
}

BoardManager::BoardManager() {
}

BoardManager::~BoardManager() {
}

std::vector<Node*> BoardManager::getAvailableNeighbors(uint8_t row, uint8_t col,  const Board &board)
{
    std::vector<Node*> v; //neighbors list
    for (int r = -1; r <= 1; r++) {
        for (int c = -1; c <= 1; c++) {
            bool validTile = row + r >= 0;
            validTile = validTile && (col + c >= 0);
            validTile = validTile && (row + r < board.getRows());
            validTile = validTile && (col + c < board.getCols());
            validTile = validTile && !(r == 0 && c == 0);
            validTile = validTile && !board.getNode(row + r, col + c)->isVisited();
            if (validTile) {
                v.push_back(board.getNode(row + r, col + c));
            }
        }
    }
    return v;
}

std::vector<std::vector<Node*> > BoardManager::getPathsFrom(uint8_t row, uint8_t col, int length, const Board &board)
{
    std::vector<std::vector<Node*> > paths;
    Node * currentNode = board.getNode(row, col);
    currentNode->markVisited();
    
    if (length == 1) {
        std::vector<Node*> ngbs = this->getAvailableNeighbors(row, col, board);
        for (int i = 0; i < ngbs.size(); i++) {
            std::vector<Node*> path;
            Node* currentNodeCopy = new Node(currentNode->letter(), currentNode->row(), currentNode->col());
            path.push_back(currentNodeCopy);
            Node* currentNgbCopy = new Node(ngbs[i]->letter(), ngbs[i]->row(), ngbs[i]->col());
            path.push_back(currentNgbCopy);
            paths.push_back(path);
        }
        
    } else {
        std::vector<Node*> ngbs = this->getAvailableNeighbors(row, col, board);
        //std::cout << "Ngbs: for letter " << currentNode->letter() << std::endl;
        //std::cout << ngbsToString(ngbs) << std::endl;
        for (int i = 0; i < ngbs.size(); i++) {
            Board cloneBoard = board;
            std::vector<std::vector<Node*> > subPaths;
            subPaths = this->getPathsFrom(ngbs[i]->row(), ngbs[i]->col(), length-1, cloneBoard);
            //std::cout << "subPaths: " << std::endl;
            //std::cout << pathsToString(subPaths) << std::endl;
         
            for (int j = 0; j < subPaths.size(); j++) {
                std::vector<Node *> currentPath = subPaths[j];
                //std::cout << "currentPath: " << std::endl;
                //std::cout << ngbsToString(currentPath) << std::endl;
                std::vector<Node*>::iterator it = currentPath.begin();
                Node* currentNodeCopy = new Node(currentNode->letter(), currentNode->row(), currentNode->col());
                currentPath.insert(it, currentNodeCopy);
                //std::cout << "currentPath with currentNode: " << std::endl;
                //std::cout << ngbsToString(currentPath) << std::endl;
                
                //std::cout << "Current paths: " << std::endl;
                //std::cout << pathsToString(paths) << std::endl;
                paths.push_back(currentPath);
                //std::cout << "Current paths with currentPath: " << std::endl;
                //std::cout << pathsToString(paths) << std::endl;
            }
        }
    }
    
    return paths;
}